import requests
import torch
import hashlib
import time
import fastrand
import math
import os
import secrets

import numba
import numpy as np

# set port from env, or default to 12121
PORT = int(os.getenv("PORT", 12121))

# create timer decorator
def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start} seconds")
        return result
    return wrapper

def create_rowhashes(n, master_seed):
    row_hashes = []
    current_seed = master_seed
    for _ in range(n):
        row_hashes.append(sha256_bytes(current_seed))
        current_seed = sha256_bytes(current_seed)
    return row_hashes, current_seed

def create_row_from_hash(n, seed):
    s0 = seed & 0xFFFFFFFFFFFFFFF
    s1 = int(seed >> 64) & 0xFFFFFFFFFFFFFFF
    out, _, _ = xorshift128plus_array(n, s0, s1)
    torch_64_max = float(1 << 64)
    return torch.tensor(out, dtype=torch.float64) / torch_64_max

@timer
def create_deterministic_rowhash_matrix(n, master_seed):
    row_hashes, next_hash = create_rowhashes(n, master_seed)
    rows = []
    for i in range(n):
        row_data = create_row_from_hash(n, int.from_bytes(row_hashes[i], "big"))
        rows.append(row_data)
    return torch.stack(rows), next_hash

@numba.njit
def xorshift128plus_array(n, s0, s1):
    # Generate n samples. s0, s1 are 64-bit seeds.
    out = np.empty(n, dtype=np.uint64)
    for i in range(n):
        # Xorshift128+ example
        x = s0
        y = s1
        s0 = y
        x ^= x << 23
        s1 = x ^ y ^ (x >> 17) ^ (y >> 26)
        out[i] = (s1 + y) & ((1 << 64) - 1)
    return out, s0, s1

def pcg_uniform_torch64(count, seed0, seed1):
    arr_int, seed0, seed1 = xorshift128plus_array(count, seed0, seed1)
    arr_float = arr_int.astype(np.float64) / (1 << 64)
    return torch.from_numpy(arr_float)

def set_seeds(seed: int):
    seed1 = seed & 0xFFFFFFFF
    seed2 = seed >> 32 & 0xFFFFFFFF
    fastrand.xorshift128plus_seed1(seed1)
    fastrand.xorshift128plus_seed2(seed2)

@timer
def pcg_uniform_torch64(count: int) -> torch.Tensor:
    """
    Returns a double precision tensor of length 'count',
    each entry in [0, 1), derived from 64-bit PCG output.
    """
    print("Generating", count, "uniform samples...")
    out = torch.empty(count, dtype=torch.float64)
    two_64 = float(1 << 64)
    for i in range(count):
        out[i] = fastrand.xorshift128plus() / two_64
    return out

@timer
def pcg_randn64(shape) -> torch.Tensor:
    """
    Returns a double precision (float64) PyTorch tensor of shape 'shape',
    filled with standard normal samples generated by the above PCG64-like RNG.
    Uses Box–Muller in a vectorized manner.
    """
    # Number of total samples needed
    numel = 1
    for s in shape:
        numel *= s

    # We need pairs for Box–Muller (two normal samples per pair).
    half = (numel + 1) // 2

    # Generate 2*half uniform [0,1) values
    u = pcg_uniform_torch64(2 * half)  # [u1(0), u1(1), ..., u1(half-1), u2(0), ..., u2(half-1)]
    u1 = u[:half]
    u2 = u[half:]

    # Box–Muller transform: r = sqrt(-2 ln(u1)), theta = 2πu2
    r = (-2.0 * u1.log()).sqrt_()
    theta = 2.0 * math.pi * u2

    # Allocate an output tensor for the final normal values
    z = torch.empty(2 * half, dtype=torch.float64)
    z[:half] = r * theta.cos()
    z[half:] = r * theta.sin()

    # If numel is odd, truncate the last extra sample
    z = z[:numel]

    return z.reshape(shape)

def sha256_bytes(data: bytes) -> bytes:
    return hashlib.sha256(data).digest()

def merkle_verify_leaf(leaf: bytes, idx: int, path: list[str], root: bytes) -> bool:
    """
    Recompute up the chain using 'path' (list of hex strings) to see if we arrive at 'root'.
    """
    current = leaf
    current_idx = idx
    for sibling_hex in path:
        sibling = bytes.fromhex(sibling_hex)
        if (current_idx % 2) == 0:  # even => left child
            current = sha256_bytes(current + sibling)
        else:  # odd => right child
            current = sha256_bytes(sibling + current)
        current_idx //= 2
    return current == root

@timer
def send_params_to_prover(n, master_seed):
    print("Sending A,B to Prover...")
    resp = requests.post(f"http://localhost:{PORT}/setAB", json={"n": n, "seed": master_seed.hex()})
    print("setAB response:", resp.json())

@timer
def get_merkle_commitment_from_prover():
    resp = requests.get(f"http://localhost:{PORT}/getCommitment")
    data = resp.json()
    commitment_root_hex = data["commitment_root"]
    commitment_root = bytes.fromhex(commitment_root_hex)
    print("Commitment root (C):", commitment_root_hex)
    return commitment_root

def send_challenge_to_prover(r):
    r_list = r.tolist()
    resp = requests.post(f"http://localhost:{PORT}/computeCR", json={"r": r_list})
    data = resp.json()
    Cr_list = data["Cr"]
    Cr = torch.tensor(Cr_list, dtype=torch.float64)
    print("Received C*r from Prover.")
    return Cr

@timer
def check_freivals(A, B, Cr, r):
    x = B.matmul(r)
    check = A.matmul(x)
    freivalds_ok = torch.allclose(check, Cr, rtol=1e-5, atol=1e-5)
    print("Freivalds check:", freivalds_ok)
    return freivalds_ok

@timer
def row_challenge(A, B, commitment_root, row_idx):
    print(f"\nRequesting row {row_idx} from Prover...")
    resp = requests.post(f"http://localhost:{PORT}/getRowProof", json={"row_idx": row_idx})
    row_data = resp.json()["row_data"]
    merkle_path = resp.json()["merkle_path"]
    merkle_ok = True
    row_checks_ok = True

    # 1) Merkle verification
    leaf_bytes = sha256_bytes(torch.tensor(row_data, dtype=torch.float64).numpy().tobytes())
    path_ok = merkle_verify_leaf(leaf_bytes, row_idx, merkle_path, commitment_root)
    if not path_ok:
        merkle_ok = False
        print("Merkle path verification failed for row", row_idx)

    # 2) Check that row_data matches row_idx of A*B (this is O(n^2) for 1 row => O(n))
    #    That's not too big, so we can do it occasionally as a spot check.
    row_of_A = A[row_idx, :]  # shape [n]
    local_check_row = row_of_A.matmul(B)  # shape [n]
    # Compare to row_data
    if not torch.allclose(local_check_row, torch.tensor(row_data, dtype=torch.float64), rtol=1e-5, atol=1e-5):
        row_checks_ok = False
        print("Row data mismatch at row", row_idx)
    else:
        print("Row", row_idx, "spot-check ok.")
    return path_ok, merkle_ok, row_checks_ok

def main():
    # ----------------------------
    # 1) Verifier picks random A, B, posts them to Prover
    # ----------------------------
    n = 16384  # small dimension for demonstration
    dtype = torch.float64
    master_seed = secrets.token_bytes(16)
    
    # because we generate matrices using row seeds, we can skip generating the full A
    # matrix on the verifier side and only generate the rows we need for the challenge below
    A, next_seed = create_deterministic_rowhash_matrix(n, master_seed)
    B, _ = create_deterministic_rowhash_matrix(n, next_seed)
    
    send_params_to_prover(n, master_seed)

    # ----------------------------
    # 2) Get Merkle root from Prover (commitment to C)
    # ----------------------------
    commitment_root = get_merkle_commitment_from_prover()

    # ----------------------------
    # 3) Generate random challenge vector r, post to computeCR
    # ----------------------------
    challenge_seed = secrets.token_bytes(16)
    r = create_row_from_hash(n, int.from_bytes(challenge_seed, "big"))
    Cr = send_challenge_to_prover(r)

    # ----------------------------
    # 4) Verifier does Freivalds check: compare A(B r) with C r
    #    We can't directly do C = A*B, that costs O(n^3).
    #    Instead we do x = B*r (O(n^2)) and then A*x (O(n^2)).
    # ----------------------------
    freivalds_ok = check_freivals(A, B, Cr, r)

    # ----------------------------
    # 5) Spot-check a few random rows with Merkle proof
    #    We do 2 random rows
    # ----------------------------

    k = 2
    chosen_rows = []
    # do this to make sure we don't choose the same row twice
    while len(set(chosen_rows)) != k:
        chosen_rows = [secrets.randbelow(n) for _ in range(k)]
    row_checks_ok = True
    merkle_ok = True
    for row_idx in chosen_rows:
        path_ok, merkle_ok, row_checks_ok = row_challenge(A, B, commitment_root, row_idx)
        if not path_ok or not row_checks_ok:
            break

    if freivalds_ok and merkle_ok and row_checks_ok:
        print("\nOverall: verification succeeded.")
    else:
        print("\nOverall: verification FAILED.")

if __name__ == "__main__":
    main()
